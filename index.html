<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Jillegal : " />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jillegal</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/serkan-ozal/jillegal">View on GitHub</a>

          <h1 id="project_title">Jillegal</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/serkan-ozal/jillegal/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/serkan-ozal/jillegal/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2><strong>What is Jillegal?</strong></h2>

<p><strong>Jillegal</strong> is a library including unknown tricks of Java. It abstracts developer from low-level details to implement those tricks.</p>

<h2><strong>What features does Jillegal have?</strong></h2>

<ul>
<li><p>Accessing and setting any value at any address (as HEX address) in application is supported.</p></li>
<li><p>Accessing real memory address of any object is supported. So you can change any object in memory by getting its address and copying your custom object to its address.</p></li>
<li><p>Sequentially allocated object pool is supported. Objects are allocated from off-heap so GC doesn't know them. With this feature, all objects in pool are exist as sequential at memory, so sequential accessing to them is faster. Because, they will be fetched to CPU cache together as limited size of CPU cache.</p></li>
</ul><h2><strong>Install</strong></h2>

<p>In your <strong>pom.xml</strong>, you must add repository and dependency for Jillegal. 
You can change <strong>jillegal.version</strong> to any existing Jillegal library version.</p>

<pre><code>...
&lt;properties&gt;
    ...
    &lt;jillegal.version&gt;1.0.0-BETA&lt;/jillegal.version&gt;
    ...
&lt;/properties&gt;
...
&lt;dependencies&gt;
    ...
    &lt;dependency&gt;
        &lt;groupId&gt;tr.com.serkanozal&lt;/groupId&gt;
        &lt;artifactId&gt;jillegal&lt;/artifactId&gt;
        &lt;version&gt;${jillegal.version}&lt;/version&gt;
    &lt;/dependency&gt;
    ...
&lt;/dependencies&gt;
...
&lt;repositories&gt;
    ...
    &lt;repository&gt;
        &lt;id&gt;serkanozal-maven-repository&lt;/id&gt;
        &lt;url&gt;https://github.com/serkan-ozal/maven-repository/raw/master/&lt;/url&gt;
    &lt;/repository&gt;
    ...
&lt;/repositories&gt;
...
</code></pre>

<p><strong>Note:</strong> 
If you don't use <strong>Maven</strong>, you can access <strong>jillegal.jar</strong> including all dependencies 
with (assuming you are using 1.0.0-BETA version of Jillegal)
<strong><a href="https://github.com/serkan-ozal/maven-repository/blob/master/tr/com/serkanozal/jillegal/1.0.0-BETA/jillegal-jar-with-dependencies-1.0.0-BETA.jar?raw=true">https://github.com/serkan-ozal/maven-repository/blob/master/tr/com/serkanozal/jillegal/1.0.0-BETA/jillegal-jar-with-dependencies-1.0.0-BETA.jar?raw=true</a></strong></p>

<h2><strong>Jillegal with a simple example</strong></h2>

<pre><code>final int OBJECT_COUNT = 10000;

OffHeapService offHeapService = OffHeapServiceFactory.getOffHeapService();

SequentialObjectPool&lt;SampleClass&gt; sequentialObjectPool = 
    offHeapService.createOffHeapPool(
        new SequentialObjectPoolCreateParameterBuilder&lt;SampleClass&gt;().
                type(SampleClass.class).
                objectCount(OBJECT_COUNT).
            build()
    );

for (int i = 0; i &lt; OBJECT_COUNT; i++) {
    SampleClass obj = sequentialObjectPool.newObject();
    obj.setOrder(i);
}

for (int i = 0; i &lt; OBJECT_COUNT; i++) {
    SampleClass obj = sequentialObjectPool.getObject(i);
    System.out.println(obj.getOrder());
}
</code></pre>

<h2><strong>Roadmap</strong></h2>

<ul>
<li><p>Off-heap array support for primitive and non-primitive types will be implemented.</p></li>
<li><p>Off-heap string support will be implemented.</p></li>
<li><p>Automatic detection and binding for complex off-heap objects will be implemented.</p></li>
<li><p>All allocated objects with <strong>new</strong> operator will be automatically allocated from <strong>off-heap</strong> without any changing in your code. Only explicit initialization will be needed.</p></li>
</ul><p>For example:</p>

<pre><code>Jillegal.initOffHeap(
    new ClassFilter() {
        public boolean filter(Class&lt;?&gt; clazz) {
            // Only new operators in my code will be instrumented to off-heap pool, so don't filter
            if (clazz.getName().startsWith("com.myproject")) {
                return false;
            }
            return true;
        }
    });
</code></pre>

<ul>
<li>
<p>Without any VM argument or additional agent, you can redefine all Java classes (including core Java classes) with your own implementation on the fly. 
For example:</p>

<pre><code>* You can add pre/post interceptors to constructors or methods programatically.  
* You can modifiy core Java classes (such as String, Integer, ...) on the fly.
* You can extend your class from any "final" defined Java class such as "String" class.
</code></pre>
</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Jillegal maintained by <a href="https://github.com/serkan-ozal">serkan-ozal</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
