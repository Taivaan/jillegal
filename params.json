{"name":"Jillegal","tagline":"Java Off Heap Object Pool and On the Fly Instrumentation Tool","body":"## **What is Jillegal?**\r\n\r\n**Jillegal** is a library including unknown tricks of Java. It abstracts developer from low-level details to implement those tricks.\r\n\r\n\r\n## **What features does Jillegal have?**\r\n* Accessing and setting any value at any address (as HEX address) in application is supported.\r\n\r\n* Accessing real memory address of any object is supported. So you can change any object in memory by getting its address and copying your custom object to its address.\r\n\r\n* Sequentially allocated off heap object pool is supported. Objects are allocated from off-heap so GC doesn't know them. With this feature, all objects in pool are exist as sequential at memory, so sequential accessing to them is faster. Because, they will be fetched to CPU cache together as limited size of CPU cache.\r\n\r\n* On the fly class instumentation without giving any VM argument to your Java application. **Jillegal agent** is loaded automatically on the fly whenever you need it.\r\n\r\n## **Install**\r\n\r\nIn your **pom.xml**, you must add repository and dependency for Jillegal. \r\nYou can change **jillegal.version** to any existing Jillegal library version.\r\n\r\n\t...\r\n\t<properties>\r\n\t\t...\r\n\t\t<jillegal.version>1.0.1-RELEASE</jillegal.version>\r\n\t\t...\r\n\t</properties>\r\n\t...\r\n\t<dependencies>\r\n\t\t...\r\n\t\t<dependency>\r\n\t\t\t<groupId>tr.com.serkanozal</groupId>\r\n\t\t\t<artifactId>jillegal</artifactId>\r\n\t\t\t<version>${jillegal.version}</version>\r\n\t\t</dependency>\r\n\t\t...\r\n\t</dependencies>\r\n\t...\r\n\t<repositories>\r\n\t\t...\r\n\t\t<repository>\r\n\t\t\t<id>serkanozal-maven-repository</id>\r\n\t\t\t<url>https://github.com/serkan-ozal/maven-repository/raw/master/</url>\r\n\t\t</repository>\r\n\t\t...\r\n\t</repositories>\r\n\t...\r\n\r\n**Note:** \r\nIf you don't use **Maven**, you can access **jillegal.jar** including all dependencies \r\nwith (assuming you are using 1.0.1-RELEASE version of Jillegal)\r\n**https://github.com/serkan-ozal/maven-repository/blob/master/tr/com/serkanozal/jillegal/1.0.0-BETA/jillegal-jar-with-dependencies-1.0.1-RELEASE.jar?raw=true**\r\n\r\n\r\n## **Jillegal with simple examples**\r\n\r\nYou can access all demo codes from here: [jillegal-demo](https://github.com/serkan-ozal/jillegal-demo)\r\n\r\n### _Direct Memory Access Example_\r\n  \r\n    DirectMemoryService directMemoryService = DirectMemoryServiceFactory.getDirectMemoryService();\r\n\t\t\r\n    SampleClass obj = new SampleClass();\r\n\t\t\r\n    long addressOfField_b = directMemoryService.addressOfField(obj, \"b\");\r\n    long addressOfField_i = directMemoryService.addressOfField(obj, \"i\");\r\n    long addressOfField_l = directMemoryService.addressOfField(obj, \"l\");\r\n\t\t\r\n    System.out.println(\"Value of b with direct memory access: \" + directMemoryService.getInt(addressOfField_b));\r\n    System.out.println(\"Value of i with direct memory access: \" + directMemoryService.getInt(addressOfField_i));\r\n    System.out.println(\"Value of l with direct memory access: \" + directMemoryService.getLong(addressOfField_l));\r\n\t\t\r\n    directMemoryService.putByte(addressOfField_b, (byte)10); // Note that b is final static field\r\n    directMemoryService.putInt(addressOfField_i, 55);\r\n    directMemoryService.putLong(addressOfField_l, 100);\r\n\r\n    System.out.println(\"Values of b, i and l are changed with direct memory access ...\");\r\n\t\t\r\n    System.out.println(\"Value of b with direct memory access: \" + directMemoryService.getByte(addressOfField_b));\r\n    System.out.println(\"Value of i with direct memory access: \" + directMemoryService.getInt(addressOfField_i));\r\n    System.out.println(\"Value of l with direct memory access: \" + directMemoryService.getLong(addressOfField_l));\r\n\t\t\r\n    ///////////////////////////////////////////////////////////////////////////////////////////\r\n\t\t\r\n    SampleClass objSource = new SampleClass();\r\n    SampleClass objTarget = new SampleClass();\r\n\t\t\r\n    objSource.setI(100);\r\n    objSource.setL(1000);\r\n\t\t\r\n    objTarget.setI(200);\r\n    objTarget.setL(2000);\r\n\r\n    System.out.println(\"Value of i on targetObject: \" + objTarget.getI());\r\n    System.out.println(\"Value of l on targetObject: \" + objTarget.getL());\r\n\t\t\r\n    directMemoryService.changeObject(objSource, objTarget);\r\n\t\t\r\n    System.out.println(\"Source object has been directly copied to target object ...\");\r\n\t\t\r\n    System.out.println(\"Value of i on targetObject: \" + objTarget.getI());\r\n    System.out.println(\"Value of l on targetObject: \" + objTarget.getL());\r\n\r\n_Output:_\r\n\r\n    Value of b with direct memory access: 100\r\n    Value of i with direct memory access: 5\r\n    Value of l with direct memory access: 10\r\n    Values of b, i and l are changed with direct memory access ...\r\n    Value of b with direct memory access: 10\r\n    Value of i with direct memory access: 55\r\n    Value of l with direct memory access: 100\r\n    Value of i on targetObject: 200\r\n    Value of l on targetObject: 2000\r\n    Source object has been directly copied to target object ...\r\n    Value of i on targetObject: 100\r\n    Value of l on targetObject: 1000\r\n\r\n### _Off Heap Pool Example_\r\n\r\n    final int OBJECT_COUNT = 10000;\r\n\t\r\n    OffHeapService offHeapService = OffHeapServiceFactory.getOffHeapService();\r\n\t\r\n    SequentialObjectPool<SampleClass> sequentialObjectPool = \r\n        offHeapService.createOffHeapPool(\r\n            new SequentialObjectPoolCreateParameterBuilder<SampleClass>().\r\n                    type(SampleClass.class).\r\n                    objectCount(OBJECT_COUNT).\r\n                build()\r\n        );\r\n   \r\n    System.out.println(\"Off heap object pool for class \" + SampleClass.class.getName() + \r\n        \" has been allocated ...\");\r\n\t\t\r\n    for (int i = 0; i < OBJECT_COUNT; i++) {\r\n        SampleClass obj = sequentialObjectPool.newObject();\r\n        obj.setOrder(i);\r\n        System.out.println(\"New object has been retrieved from off heap pool and set order value to \" + i);\r\n     }\r\n    \t\r\n    for (int i = 0; i < OBJECT_COUNT; i++) {\r\n        SampleClass obj = sequentialObjectPool.getObject(i);\r\n        System.out.println(\"Order value of \" + i + \". object at off heap pool: \" + obj.getOrder());\r\n    }\r\n\r\n_Output:_\r\n\r\n    Off heap object pool for class tr.com.serkanozal.jillegaltest.OffHeapDemo$SampleClass has been allocated ...\r\n    New object has been retrieved from off heap pool and set order value to 0\r\n    New object has been retrieved from off heap pool and set order value to 1\r\n    New object has been retrieved from off heap pool and set order value to 2\r\n    ...\r\n    New object has been retrieved from off heap pool and set order value to 9999\r\n    Order value of 0. object at off heap pool: 0\r\n    Order value of 1. object at off heap pool: 1\r\n    Order value of 2. object at off heap pool: 2\r\n    ...\r\n    Order value of 9999. object at off heap pool: 9999\r\n\r\n### _Instrumentation Example_\r\n\r\n    Jillegal.init();\r\n\t\t\r\n    System.out.println(\"Before Intrumentation: \");\r\n    System.out.println(\"=====================================================\");\r\n\t\t\r\n    SampleClass obj1 = new SampleClass();\r\n    obj1.methodToIntercept();\r\n\t\t\r\n    System.out.println(\"=====================================================\");\r\n\t\t\r\n\t\t\r\n    System.out.println(\"After Intrumentation: \");\r\n    System.out.println(\"=====================================================\");\r\n\t\t\r\n    InstrumenterService instrumenterService = InstrumenterServiceFactory.getInstrumenterService();\r\n    Instrumenter<SampleClass> inst = instrumenterService.getInstrumenter(SampleClass.class);\r\n    GeneratedClass<SampleClass> redefinedClass =\r\n        \t\t\r\n         inst.\r\n                \r\n            insertBeforeConstructors(\r\n                new BeforeConstructorInterceptor<SampleClass>() {\r\n                    @Override\r\n                    public void beforeConstructor(SampleClass obj, \r\n                                                    Constructor<SampleClass> constructor, Object[] args) {\r\n                        System.out.println(\"Intercepted by Jillegal before constructor ...\");\r\n                    }\r\n                }).\r\n\t\t\t\t\t\t\r\n            insertAfterConstructors(\r\n                \"System.out.println(\\\"Intercepted by Jillegal after constructor ...\\\");\").\r\n                    \r\n            insertBeforeMethod(\"methodToIntercept\", \r\n                new BeforeMethodInterceptor<SampleClass>() {\r\n                    @Override\r\n                    public void beforeMethod(SampleClass obj, Method method, Object[] args) {\r\n                        System.out.println(\"Intercepted by Jillegal before methodToIntercept method ...\");\r\n                    }\r\n                }).\r\n\t\t\t\t\t\t\t\r\n            insertAfterMethod(\"methodToIntercept\", \r\n                  \"System.out.println(\\\"Intercepted by Jillegal after methodToIntercept method ...\\\");\").\r\n                    \t\t\t\r\n        build();\r\n\r\n    instrumenterService.redefineClass(redefinedClass); \r\n        \r\n    SampleClass obj2 = new SampleClass();\r\n    obj2.methodToIntercept();\r\n        \r\n    System.out.println(\"=====================================================\");\r\n\r\n_Output:_\r\n\r\n    Class Path: D:\\Computer Sciences\\Software\\Workspaces\\Eclipse Workspace\\T2\\jillegal-demo\\target\\classes;C:\\Users\\Asus\\.m2\\repository\\tr\\com\\serkanozal\\jillegal\\1.0.1-RELEASE\\jillegal-1.0.1-RELEASE.jar;C:\\Users\\Asus\\.m2\\repository\\tr\\com\\serkanozal\\jillegal-agent\\1.0.0-RELEASE\\jillegal-agent-1.0.0-RELEASE.jar;C:\\Users\\Asus\\.m2\\repository\\com\\sun\\tools\\1.6.0\\tools-1.6.0.jar;C:\\Users\\Asus\\.m2\\repository\\cglib\\cglib\\2.2\\cglib-2.2.jar;C:\\Users\\Asus\\.m2\\repository\\asm\\asm\\3.1\\asm-3.1.jar;C:\\Users\\Asus\\.m2\\repository\\org\\javassist\\javassist\\3.17.1-GA\\javassist-3.17.1-GA.jar;C:\\Users\\Asus\\.m2\\repository\\commons-lang\\commons-lang\\2.6\\commons-lang-2.6.jar;C:\\Users\\Asus\\.m2\\repository\\log4j\\log4j\\1.2.16\\log4j-1.2.16.jar\r\n    OS Name: Windows 7\r\n    Using ClassPath: D:\\Computer Sciences\\Software\\Workspaces\\Eclipse Workspace\\T2\\jillegal-demo\\target\\classes;C:\\Users\\Asus\\.m2\\repository\\tr\\com\\serkanozal\\jillegal\\1.0.1-RELEASE\\jillegal-1.0.1-RELEASE.jar;C:\\Users\\Asus\\.m2\\repository\\tr\\com\\serkanozal\\jillegal-agent\\1.0.0-RELEASE\\jillegal-agent-1.0.0-RELEASE.jar;C:\\Users\\Asus\\.m2\\repository\\com\\sun\\tools\\1.6.0\\tools-1.6.0.jar;C:\\Users\\Asus\\.m2\\repository\\cglib\\cglib\\2.2\\cglib-2.2.jar;C:\\Users\\Asus\\.m2\\repository\\asm\\asm\\3.1\\asm-3.1.jar;C:\\Users\\Asus\\.m2\\repository\\org\\javassist\\javassist\\3.17.1-GA\\javassist-3.17.1-GA.jar;C:\\Users\\Asus\\.m2\\repository\\commons-lang\\commons-lang\\2.6\\commons-lang-2.6.jar;C:\\Users\\Asus\\.m2\\repository\\log4j\\log4j\\1.2.16\\log4j-1.2.16.jar\r\n    Agent path: C:\\Users\\Asus\\.m2\\repository\\tr\\com\\serkanozal\\jillegal-agent\\1.0.0-RELEASE\\jillegal-agent-1.0.0-RELEASE.jar\r\n    Agentmain: sun.instrument.InstrumentationImpl@7f971afc - Arguments: null\r\n    Before Intrumentation: \r\n    =====================================================\r\n    SampleInstrumentClass.SampleClassToInstrument()\r\n    SampleInstrumentClass.methodToIntercept()\r\n    =====================================================\r\n    After Intrumentation: \r\n    =====================================================\r\n    Intercepted by Jillegal before constructor ...\r\n    SampleInstrumentClass.SampleClassToInstrument()\r\n    Intercepted by Jillegal after constructor ...\r\n    Intercepted by Jillegal before methodToIntercept method ...\r\n    SampleInstrumentClass.methodToIntercept()\r\n    Intercepted by Jillegal after methodToIntercept method ...\r\n    =====================================================\r\n\r\n## **Roadmap**\r\n* Off-heap array support for primitive and non-primitive types will be implemented.\r\n\r\n* Off-heap string support will be implemented.\r\n\r\n* Automatic detection and binding for complex off-heap objects will be implemented.\r\n\r\n* All allocated objects with **new** operator will be automatically allocated from **off-heap** without any changing in your code. Only explicit initialization will be needed.\r\n\r\nFor example:\r\n\r\n    Jillegal.initOffHeap(\r\n        new ClassFilter() {\r\n            public boolean filter(Class<?> clazz) {\r\n                // Only new operators in my code will be instrumented to off-heap pool, so don't filter\r\n                if (clazz.getName().startsWith(\"com.myproject\")) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        });","google":"UA-39596978-1","note":"Don't delete this file! It's used internally to help with page regeneration."}